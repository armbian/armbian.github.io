name: Sync 3rd party packages
on:
  workflow_dispatch:
  workflow_call:
    inputs:
      ACCESS_NAME:
        required: false
        type: string
        default: ${{ github.repository_owner }}
      BUILD_BRANCH:
        required: false
        type: string
        default: 'main'
      BUILD_RUNNER:
        required: false
        type: string
        default: "ubuntu-latest"
      HOST_DEPLOY:
        required: false
        type: string
        default: "repo.armbian.com"
      HOST_USER:
        required: false
        type: string
        default: "upload"
      REFERENCE:
        required: false
        type: string
        default: "main"
    secrets:
      GPG_KEY1:
        required: true
      GPG_KEY2:
        required: true
      ACCESS_TOKEN:
        required: true
      KEY_UPLOAD:
        required: false
      HOST_UPLOAD:
        required: true
      HOST_UPLOAD_USER:
        required: true
      HOST_UPLOAD_PORT:
        required: true
      KNOWN_HOSTS_ARMBIAN_UPLOAD:
        required: true

env:
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  PR_NUMBER: ${{ github.event.number }}

jobs:

  start:
    runs-on: ${{ inputs.BUILD_RUNNER }}
    name: "Mirror"
    outputs:
      matrix: ${{steps.lists.outputs.matrix}}
    steps:

      - name: "Install SSH key"
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: "Create a temporary artifact folder"
        run: |

          mkdir -p downloads
          cd downloads
          echo "${{ inputs.HOST_DEPLOY }}/" > url.txt
          echo "artifacts/${{ env.PR_NUMBER }}/" > path.txt

      - name: "Upload Artifact"
        uses: actions/upload-artifact@v4
        with:
          name: assets-for-download
          path: downloads
          overwrite: true
          retention-days: 5

      - name: Remove temporary repositories
        run: |
          # Note: StrictHostKeychecking=no is used here; consider using proper known_hosts in production
          ssh -o StrictHostKeychecking=no -p ${{ secrets.HOST_UPLOAD_PORT }} ${{ inputs.HOST_USER }}@${{ inputs.HOST_DEPLOY }} "rm -rf storage/artifacts/*"

      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: armbian/os
          path: os
          fetch-depth: '2'
          clean: false

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v43
        with:
          path: os
          files: |
            external/*.conf

      - name: Build list
        id: lists
        run: |
          # Install jq if not available
          command -v jq >/dev/null 2>&1 || sudo apt-get install -y jq

          echo "::debug::Changed files: ${{ steps.changed-files.outputs.all_changed_files }}" >&2
          echo "::debug::REFERENCE input: ${{ inputs.REFERENCE }}" >&2

          # Build list of conf files
          if [[ "${{ inputs.REFERENCE }}" =~ ^(main|)$ ]]; then
            # Get all conf files
            MATRIX_LIST=()
            while IFS= read -r -d '' conf_file; do
              conf_name=$(basename "$conf_file" .conf)
              MATRIX_LIST+=("$conf_name")
            done < <(find os/external/*.conf -print0 | sort -z)
          else
            # Get only changed conf files
            MATRIX_LIST=()
            CHANGED="${{ steps.changed-files.outputs.all_changed_files }}"
            if [[ -n "$CHANGED" ]]; then
              while IFS= read -r conf_file; do
                conf_name=$(echo "$conf_file" | cut -d"." -f1 | cut -d"/" -f2)
                MATRIX_LIST+=("$conf_name")
              done < <(echo "$CHANGED" | tr " " "\n")
            fi
          fi

          echo "::debug::MATRIX content: ${MATRIX_LIST[*]}" >&2

          # Build detailed matrix - expand each arch and release combination
          MATRIX_JSON=$(
          for conf_file in "${MATRIX_LIST[@]}"; do
            echo "::debug::Processing conf file: ${conf_file}" >&2
            [[ -f "os/external/${conf_file}.conf" ]] || continue

            # Source the conf file to get variables
            . "os/external/${conf_file}.conf"

            echo "::debug::${conf_file} - ARCH: ${ARCH}, RELEASE: ${RELEASE}, TARGET: ${TARGET}" >&2

            # Expand architectures (colon-separated)
            archs=($(echo "$ARCH" | tr ':' ' '))

            # Expand releases
            if [[ "${RELEASE}" == "all" ]]; then
              # Default releases for "all"
              releases=("bookworm" "jammy" "noble")
            elif [[ "${RELEASE}" == *":"* ]]; then
              # Colon-separated releases
              IFS=':' read -ra releases <<< "$RELEASE"
            else
              # Single release
              releases=("$RELEASE")
            fi

            # Generate matrix entry for each arch x release combination
            for arch in "${archs[@]}"; do
              for release in "${releases[@]}"; do
                # Determine if we need QEMU (non-amd64)
                needs_qemu="false"
                [[ "$arch" != "amd64" ]] && needs_qemu="true"

                # Determine Docker image based on release
                case "${release}" in
                  bookworm|bullseye|buster|trixie|sid)
                    docker_image="debian:${release}"
                    ;;
                  jammy|focal|bionic|noble|mantic|lunar)
                    docker_image="ubuntu:${release}"
                    ;;
                  *)
                    docker_image="debian:bookworm"
                    ;;
                esac

                echo "::debug::Generating entry: package=${conf_file}, arch=${arch}, release=${release}, needs_qemu=${needs_qemu}" >&2

                # Output JSON object for this combination
                jq -n \
                  --arg name "${conf_file}" \
                  --arg arch "${arch}" \
                  --arg release "${release}" \
                  --arg target "${TARGET:-main}" \
                  --arg method "${METHOD:-aptly}" \
                  --arg install "${INSTALL:-}" \
                  --arg docker_image "${docker_image}" \
                  --arg needs_qemu "${needs_qemu}" \
                  '{name: $name, arch: $arch, release: $release, target: $target, method: $method, install: $install, docker_image: $docker_image, needs_qemu: $needs_qemu}'
              done
            done
          done | jq -s '{"include": .}' | jq -c
          )

          echo "matrix=${MATRIX_JSON}" >> $GITHUB_OUTPUT

          # Debug: Output matrix to summary
          echo "::notice::Matrix generation complete" >&2
          echo "## Matrix output" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          for conf_file in "${MATRIX_LIST[@]}"; do
            [[ -f "os/external/${conf_file}.conf" ]] || continue
            . "os/external/${conf_file}.conf"

            # Expand architectures and releases for display
            archs=($(echo "$ARCH" | tr ':' ' '))
            if [[ "${RELEASE}" == "all" ]]; then
              releases=("bookworm" "jammy" "noble")
            elif [[ "${RELEASE}" == *":"* ]]; then
              IFS=':' read -ra releases <<< "$RELEASE"
            else
              releases=("$RELEASE")
            fi

            # Display each combination
            for arch in "${archs[@]}"; do
              for release in "${releases[@]}"; do
                # Determine QEMU for display
                needs_qemu="false"
                [[ "$arch" != "amd64" ]] && needs_qemu="true"
                qemu_label=""
                [[ "$needs_qemu" == "true" ]] && qemu_label=" (QEMU)"
                echo "package=${conf_file}, ARCH=${arch}, RELEASE=${release}, qemu=${needs_qemu}${qemu_label}" >> $GITHUB_STEP_SUMMARY
              done
            done
          done
          echo '```' >> $GITHUB_STEP_SUMMARY
          echo "## Generated JSON Matrix" >> $GITHUB_STEP_SUMMARY
          echo '```json' >> $GITHUB_STEP_SUMMARY
          echo "${MATRIX_JSON}" | jq . >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  download:
    needs: [start]
    outputs:
      project: ${{steps.make.outputs.project}}
    strategy:
      fail-fast: false
      max-parallel: 18
      matrix:
        include: ${{fromJson(needs.start.outputs.matrix)}}

    name: "${{ matrix.name }} (arch: ${{ matrix.arch }}, release: ${{ matrix.release }})"
    runs-on: ${{ inputs.BUILD_RUNNER }}
    container:
      image: ${{ matrix.docker_image }}
      options: --user root
    steps:

      - name: Install SSH key
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.KEY_UPLOAD }}
          known_hosts: ${{ secrets.KNOWN_HOSTS_ARMBIAN_UPLOAD }}
          if_key_exists: replace

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY1 }}

      - name: Import GPG key
        uses: crazy-max/ghaction-import-gpg@v6
        with:
          gpg_private_key: ${{ secrets.GPG_KEY2 }}

      - name: Checkout Armbian OS scripts
        uses: actions/checkout@v4
        with:
          repository: armbian/os
          path: os
          ref: ${{ inputs.REFERENCE }}
          fetch-depth: '1'
          clean: false

      - name: Checkout Armbian build script
        uses: actions/checkout@v4
        with:
          repository: armbian/build
          path: build
          fetch-depth: '1'
          clean: false

      - name: Install QEMU for cross-architectures
        if: matrix.needs_qemu == 'true'
        run: |
          apt-get update
          apt-get install -y qemu-user-static binfmt-support

      - name: Install Aptly
        run: |
          # Note: Consider adding checksum verification for downloaded files
          wget https://github.com/aptly-dev/aptly/releases/download/v1.5.0/aptly_1.5.0_amd64.deb
          dpkg -i aptly_1.5.0_amd64.deb
          rm aptly_1.5.0_amd64.deb

      - name: Install all keys
        run: |
          find os/external/keys/ -type f -name "*.gpg" -exec gpg --import --no-default-keyring --keyring trustedkeys.gpg "{}" \;
          apt-get -y install debian-keyring ubuntu-keyring
          gpg --no-default-keyring --keyring trustedkeys.gpg --keyserver keyserver.ubuntu.com --recv-keys 648ACFD622F3D138 0E98404D386FA1D9

      - name: Download
        id: calculate
        run: |
          echo "::debug::Matrix variables:"
          echo "::debug::  name: ${{ matrix.name }}"
          echo "::debug::  arch: ${{ matrix.arch }}"
          echo "::debug::  release: ${{ matrix.release }}"
          echo "::debug::  docker_image: ${{ matrix.docker_image }}"
          echo "::debug::  needs_qemu: ${{ matrix.needs_qemu }}"
          echo "::debug::  target: ${{ matrix.target }}"
          echo "::debug::  method: ${{ matrix.method }}"

          # default download folder
          SOURCE="temp/"
          mkdir -p ${SOURCE}

          # read config
          echo "::debug::Sourcing config file: os/external/${{ matrix.name }}.conf"
          . os/external/${{ matrix.name }}.conf

          echo "::debug::Config loaded - URL: ${URL}, KEY: ${KEY}, INSTALL: ${INSTALL}, ARCH: ${ARCH}, RELEASE: ${RELEASE}"

          APTLY_CONF="-max-tries=3 "
          [[ "${CHECKSUM}" == "ignore" ]] && APTLY_CONF+="-ignore-checksums "
          [[ "${SIGNATURES}" == "ignore" ]] && APTLY_CONF+="-ignore-signatures "

          # add armbian repository key
          # Note: Consider adding GPG key verification
          wget https://apt.armbian.com/armbian.key -O key
          gpg --dearmor < key | tee /usr/share/keyrings/armbian.gpg > /dev/null
          chmod go+r /usr/share/keyrings/armbian.gpg

          # read existing releases
          ALL_RELEASES=($(grep -rw build/config/distributions/*/support -ve 'eos' | cut -d"/" -f4 ))
          #ALL_RELEASES=("bookworm" "noble")
          # recreate folder structure as we are uploading to our system
          for i in ${ALL_RELEASES[@]}; do
              mkdir -p build/output/{debs,debs-beta}/${i}
              mkdir -p build/output/{debs,debs-beta}/extra/${i}-utils
              mkdir -p build/output/{debs,debs-beta}/extra/${i}-desktop
              # add all armbian repositories
              echo "deb [arch=armhf,arm64,amd64,i386,riscv64 signed-by=/usr/share/keyrings/armbian.gpg] http://apt.armbian.com ${i} main ${i}-utils ${i}-desktop" | tee /etc/apt/sources.list.d/armbian-${i}.list
          done

          # Add foreign architecture if using QEMU
          if [[ "${{ matrix.needs_qemu }}" == "true" ]]; then
              case "${{ matrix.arch }}" in
                  arm64)
                      dpkg --add-architecture arm64
                      ;;
                  armhf)
                      dpkg --add-architecture armhf
                      ;;
                  riscv64)
                      dpkg --add-architecture riscv64
                      ;;
              fi
          fi

          # update and get version
          apt-get update
          apt-get search ${INSTALL%% *}
          BEFORE_VERSION=$(apt-get search ${INSTALL%% *} 2>/dev/null | grep "^${INSTALL%% *}"/ | cut -d" " -f2 | cut -d":" -f2 || true)
          echo "BEFORE_VERSION=${BEFORE_VERSION}" >> $GITHUB_OUTPUT
          # we use different download metods (github, aplty)
          if [[ ${METHOD} == gh ]]; then
              gh release download ${TAG} -p '*.deb' --repo ${URL} --dir temp
          elif [[ ${METHOD} == direct ]]; then
              wget -O ${SOURCE}/${{ matrix.name }}.deb ${URL}
          else
              SOURCE="/root/.aptly/public/"
              COMPONENT="main"
              [[ $KEY == "./" || $KEY == "stable" || $KEY == "public" || $KEY == "stable non-free" ]] && COMPONENT=""
              [[ $GLOB != *Name* && $GLOB != *Version* ]] && ADDITIONAL_FILTER="-filter-with-deps"
              aptly -ignore-signatures -filter="$GLOB" ${ADDITIONAL_FILTER} -architectures="${{ matrix.arch }}" mirror create ${{ matrix.name }}-${{ matrix.release }} $(echo ${URL}) $(echo ${KEY}) $(echo ${COMPONENT})
              aptly -max-tries=20 -ignore-signatures ${APTLY_CONF} mirror update ${{ matrix.name }}-${{ matrix.release }}
              aptly snapshot create ${{ matrix.name }}-${{ matrix.release }} from mirror ${{ matrix.name }}-${{ matrix.release }}
              aptly publish -architectures="${{ matrix.arch }}" -batch=true -passphrase=${{ secrets.GPG_PASSPHRASE1 }} snapshot ${{ matrix.name }}-${{ matrix.release }}
          fi

          # Cleaning exceptions
          find $SOURCE -type f -name "*-dbg_*" | xargs rm || true
          find $SOURCE -type f -name "zoom_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "microsoft-edge*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-generic*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-arm64_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-rk3399_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-rk3588_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-tegrax1_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-rpi3arm64*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-rpi4arm64*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box*-android*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "code_*" | sort | head -n -3 | xargs rm || true
          find $SOURCE -type f -name "box64_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "box86_*" | sort | head -n -1 | xargs rm || true
          find $SOURCE -type f -name "chromium_*" | sort | head -n -3 | xargs rm || true
          find $SOURCE -type f -name "chromium-browser_*" | sort | head -n -3 | xargs rm || true
          find $SOURCE -type f -name "chromium-codecs-ffmpeg_*" | sort | head -n -2 | xargs rm || true
          find $SOURCE -type f -name "chromium-codecs-ffmpeg-extra_*" | sort | head -n -2 | xargs rm || true

          # repack deb files
          apt-get install -y devscripts
          DEBS=($(find "${SOURCE}"* -type f -name '*thunderbird*.deb' -o -name '*chromium-browser*.deb' -o -name '*chromium_*.deb' -o -name '*chromium-l10n_*.deb' -o -name '*chromium-driver*.deb' -o -name '*firefox_*.deb'))
          for d in "${DEBS[@]}"; do
            BEFORE=$(deb-reversion -c ${d} -s armbian)
            # add epoch 9
            AFTER=9:$(echo $BEFORE | cut -d":" -f2)
            echo "$d : $BEFORE -> $AFTER"
            DEBEMAIL=info@armbian.com deb-reversion -v $AFTER -s armbian $d
            rm $d
            mv *.deb ${SOURCE}
          done

          # store info to GitHub Actions
          echo "<details><summary>Show packages</summary><p>" >> $GITHUB_STEP_SUMMARY
          echo "Before: $BEFORE_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          AFTER_VERSION=$(find $SOURCE -type f -name "${INSTALL%% *}*.deb" -exec dpkg-deb -f {} Version \; | sort | uniq | tail -n 1 | cut -d":" -f2)

          echo "AFTER_VERSION=${AFTER_VERSION}" >> $GITHUB_OUTPUT

          echo "After: $AFTER_VERSION" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          find $SOURCE -type f -name "*.deb" | rev | cut -d"/" -f1 | rev | sed -e 's/^/- /;'>> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "</details>" >> $GITHUB_STEP_SUMMARY

          if [[ ${TARGET} == main ]]; then
                  if grep -qE 'B' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs-beta/ \;; fi
                  if grep -qE 'S' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs/ \;; fi
          elif [[ ${RELEASE} == all ]]; then
              for i in ${ALL_RELEASES[@]}; do
                  if grep -qE 'B' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs-beta/extra/${i}-${TARGET} \;; fi
                  if grep -qE 'S' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs/extra/${i}-${TARGET} \;; fi
              done
          else
              elements=($(echo $RELEASE | tr ':' "\n"))
              for SELECTED_RELEASE in "${elements[@]}"; do
                 if grep -qE 'B' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs-beta/extra/${SELECTED_RELEASE}-${TARGET} \;; fi
                 if grep -qE 'S' <<< "$REPOSITORY"; then find $SOURCE -type f -name "*.deb" -exec cp {} build/output/debs/extra/${SELECTED_RELEASE}-${TARGET} \;; fi
              done
          fi

      - name: "Deploy to stable server. Old: ${{ steps.calculate.outputs.BEFORE_VERSION }} - New: ${{ steps.calculate.outputs.AFTER_VERSION }}"
        if: ${{ steps.calculate.outputs.BEFORE_VERSION != steps.calculate.outputs.AFTER_VERSION }}
        run: |
          # Note: StrictHostKeychecking=no is used here; consider using proper known_hosts in production
          rsync -e "ssh -o StrictHostKeychecking=no -p ${{ secrets.HOST_UPLOAD_PORT }}" -arvc build/output/debs/ ${{ secrets.HOST_UPLOAD_USER }}@${{ secrets.HOST_UPLOAD }}:storage/debs

      - name: "Deploy to beta server"
        run: |
          # Note: StrictHostKeychecking=no is used here; consider using proper known_hosts in production
          rsync -e "ssh -o StrictHostKeychecking=no -p ${{ secrets.HOST_UPLOAD_PORT }}" -arvc build/output/debs-beta/ ${{ secrets.HOST_UPLOAD_USER }}@${{ secrets.HOST_UPLOAD }}:storage/debs-beta

      - name: Build testing repository
        run: |
          # read config once again
          . os/external/${{ matrix.name }}.conf
          cd build
          mkdir -p output/repository/public
          sed -i 's|"gpgProvider": ".*"|"gpgProvider": "gpg2"|g' tools/repository/aptly.conf
          tools/repository/repo -i output/debs-beta -c update

          # Note: StrictHostKeychecking=no is used here; consider using proper known_hosts in production
          ssh -o StrictHostKeychecking=no -p ${{ secrets.HOST_UPLOAD_PORT }} ${{ inputs.HOST_USER }}@${{ inputs.HOST_DEPLOY }} "mkdir -p storage/artifacts/${{ env.PR_NUMBER }}/${{ matrix.name }}"
          rsync -arvc -e "ssh -o StrictHostKeychecking=no -p ${{ secrets.HOST_UPLOAD_PORT }}" output/repository/public/ ${{ inputs.HOST_USER }}@${{ inputs.HOST_DEPLOY }}:"storage/artifacts/${{ env.PR_NUMBER }}/${{ matrix.name }}"

  test:

    name: "Test matrix"
    needs: download
    runs-on: ${{ inputs.BUILD_RUNNER }}
    outputs:
      matrix: ${{ steps.json.outputs.JSON_CONTENT }}
    steps:

      - name: Checkout
        uses: actions/checkout@v4
        with:
          repository: armbian/os
          path: os
          fetch-depth: '2'
          clean: false

      - name: Get changed files
        id: changed-files
        uses: tj-actions/changed-files@v43
        with:
          path: os
          files: |
            external/*.conf

      - name: "Make JSON"
        id: json
        run: |
          echo 'JSON_CONTENT<<EOF' >> $GITHUB_OUTPUT
          # define docker images where we will run test install (amd64 native)
          dockerimages=("debian:bookworm" "debian:trixie" "ubuntu:jammy" "ubuntu:noble")
          # define QEMU architectures for cross-arch testing
          qemu_archs=("arm64" "riscv64")

          echo "::debug::Changed files: ${{ steps.changed-files.outputs.all_changed_files }}" >&2
          echo "::debug::REFERENCE: ${{ inputs.REFERENCE }}" >&2

          # read packages and loop them
          packages=$(echo ${{ steps.changed-files.outputs.all_changed_files }} | tr " " "\n" | cut -d"." -f1 | cut -d"/" -f2)
          [[ "${{ inputs.REFERENCE }}" =~ ^(main|)$ ]] && packages=($(grep -rw os/external/*.conf -e amd64 | grep -v haos | cut -d"/" -f3 | cut -d"." -f1))

          echo "::debug::Packages to test: ${packages}" >&2

          # Build test matrix entries
          for i in "${packages[@]}"; do
              echo "::debug::Processing package: ${i}" >&2
              # read config file
              . os/external/${i}.conf

              # Get architectures from conf (colon-separated)
              archs=($(echo $ARCH | tr ':' " "))

              # Native amd64 docker testing
              if [[ -n "${INSTALL}" && "${ARCH}" == *amd64* ]]; then
                  if [[ $RELEASE != all ]]; then
                      for j in ${dockerimages[@]}; do
                          elements=($(echo $RELEASE | tr ':' "\n"))
                          for SELECTED_RELEASE in "${elements[@]}"; do
                              if [[ $j == *"${SELECTED_RELEASE}"* ]]; then
                                  echo "{\"package\":\"${i}\",\"image\":\"$j\",\"arch\":\"amd64\",\"type\":\"native\"}"
                              fi
                          done
                      done
                  else
                      for j in ${dockerimages[@]}; do
                          echo "{\"package\":\"${i}\",\"image\":\"$j\",\"arch\":\"amd64\",\"type\":\"native\"}"
                      done
                  fi
              fi

              # QEMU testing for arm64 and riscv64
              for test_arch in "${qemu_archs[@]}"; do
                  if [[ " ${archs[@]} " =~ " ${test_arch} " && -n "${INSTALL}" ]]; then
                      # Determine matching docker image based on RELEASE
                      if [[ $RELEASE != all ]]; then
                          elements=($(echo $RELEASE | tr ':' "\n"))
                          for SELECTED_RELEASE in "${elements[@]}"; do
                              for j in ${dockerimages[@]}; do
                                  if [[ $j == *"${SELECTED_RELEASE}"* ]]; then
                                      echo "{\"package\":\"${i}\",\"image\":\"$j\",\"arch\":\"${test_arch}\",\"type\":\"qemu\"}"
                                  fi
                              done
                          done
                      else
                          # Test all releases when RELEASE=all
                          for j in ${dockerimages[@]}; do
                              echo "{\"package\":\"${i}\",\"image\":\"$j\",\"arch\":\"${test_arch}\",\"type\":\"qemu\"}"
                          done
                      fi
                  fi
              done
          done | jq -s >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT
          echo "::notice::Test matrix generation complete" >&2

  gradle:
    needs: test
    strategy:
      fail-fast: false
      max-parallel: 32
      matrix:
        include: ${{ fromJSON(needs.test.outputs.matrix) }}

    name: "${{ matrix.image.package }} (arch: ${{ matrix.image.arch }}, type: ${{ matrix.image.type }})"
    timeout-minutes: 30
    runs-on: ${{ inputs.BUILD_RUNNER }}
    container:
        image: "${{ matrix.image.image }}"
    steps:

      - name: Download a single artifact
        uses: actions/download-artifact@v4
        with:
          name: assets-for-download
          path: downloads

      - name: Checkout Armbian OS Config
        uses: actions/checkout@v4
        with:
          repository: armbian/os
          ref: ${{ inputs.REFERENCE }}
          clean: false
          fetch-depth: 1
          path: os

      - name: Install QEMU binfmt for cross-arch testing
        if: matrix.image.type == 'qemu'
        run: |
          apt update
          apt install -y qemu-user-static binfmt-support

      - name: Install
        run: |
          # source vars
          . "os/external/${{ matrix.image.package }}.conf"

          URL=$(cat downloads/url.txt)$(cat downloads/path.txt)$(echo "${{ matrix.image.package }}" | cut -d":" -f1)

          export DEBIAN_FRONTEND=noninteractive
          RELEASE=$(echo "${{ matrix.image.image }}" | cut -d":" -f2)
          apt update
          apt -y install wget gpg

          # add armbian repository
          # Note: Consider adding GPG key verification
          wget https://${URL}/armbian.key -O key
          gpg --dearmor < key | tee /usr/share/keyrings/armbian.gpg > /dev/null
          chmod go+r /usr/share/keyrings/armbian.gpg
          echo "deb [signed-by=/usr/share/keyrings/armbian.gpg] http://${URL} $RELEASE main ${RELEASE}-utils ${RELEASE}-desktop" | tee /etc/apt/sources.list.d/armbian.list
          apt update -y
          apt upgrade -y

          # For QEMU testing, add foreign architecture
          if [[ "${{ matrix.image.type }}" == "qemu" ]]; then
              case "${{ matrix.image.arch }}" in
                  arm64)
                      dpkg --add-architecture arm64
                      ;;
                  riscv64)
                      dpkg --add-architecture riscv64
                      ;;
              fi
              apt update
          fi

          # install packages / except howdy as its too large
          export DEBIAN_FRONTEND=noninteractive
          for i in ${INSTALL}; do
              if [[ "${{ matrix.image.type }}" == "qemu" ]]; then
                  # Install with architecture suffix for QEMU
                  case "${{ matrix.image.arch }}" in
                      arm64)
                          apt-get install -y ${i}:arm64 || echo "Failed to install ${i}:arm64 (may be unavailable)"
                          ;;
                      riscv64)
                          apt-get install -y ${i}:riscv64 || echo "Failed to install ${i}:riscv64 (may be unavailable)"
                          ;;
                  esac
              else
                  # Native install
                  apt-get install -y $i
              fi
          done

  clean:

    name: "Clean"
    needs: gradle
    runs-on: ${{ inputs.BUILD_RUNNER }}
    steps:

      - name: "Lets clean artifacts that are useless"
        uses: geekyeggo/delete-artifact@v4
        with:
          name: assets-for-download
          failOnError: false
